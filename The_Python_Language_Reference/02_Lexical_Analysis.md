[Go Back](./README.md)

# <a name="2"></a> 2. Lexical analysis

A Python program is read by a parser. Input to the parser is a stream of tokens, generated by the lexical analyzer. This chapter describes how the lexical analyzer breaks a file into tokens.

Python reads program text as **Unicode code points**; the encoding of a source file can be given by an encoding declaration and defaults to UTF-8. If the source file cannot be decoded, a ``SyntaxError`` is raised.

## <a name="2_1"></a> 2.1. Line structure

A Python program is divided into a number of _logical lines_.

### <a name="2_1_1"></a> 2.1.1. Logical lines

The end of a logical line is represented by the token ``NEWLINE``. Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound statements).

### <a name="2_1_2"></a> 2.1.2. Physical lines

A physical line is a sequence of characters terminated by an _end-of-line sequence_. In source files and strings, any of the standard platform line termination sequences can be used - the **Unix** form using _ASCII LF (linefeed)_, the **Windows** form using the _ASCII CR LF (return linefeed)_, or the old **Macintosh** form using the _ASCII CR (return)_ character.

### <a name="2_1_3"></a> 2.1.3. Comments

A comment starts with a hash character ``#`` that is not part of a string literal, and ends at the end of the physical line. Comments are ignored by the syntax; **they are not tokens**.

### <a name="2_1_4"></a> 2.1.4. Encoding declarations

If a comment in the first or second line of the Python script matches the regular expression ``coding[=:]\s*([-\w.]+)``, this comment is processed as an **encoding declaration**; the first group of this expression names the encoding of the source code file. The encoding declaration must appear on a line of its own. If it is the second line, the first line must also be a comment-only line. The recommended forms of an encoding expression are

```python3
# -*- coding: <encoding-name> -*-
```

### <a name="2_1_5"></a> 2.1.5. Explicit line joining

Two or more physical lines may be joined into logical lines using backslash characters ``\``, as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it is joined with the following forming a single logical line, deleting the backslash and the following end-of-line character. For example:

```python3
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
```

A line ending in a backslash cannot carry a comment. A backslash **does not continue a comment**. A backslash does not continue a token except for string literals (i.e., tokens other than string literals cannot be split across physical lines using a backslash). A backslash is illegal elsewhere on a line outside a string literal.

### <a name="2_1_6"></a> 2.1.6. Implicit line joining

**Expressions in parentheses, square brackets or curly braces can be split over more than one physical line without using backslashes**. For example:

```python3
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
```

Implicitly continued lines **can carry comments**. The indentation of the continuation lines is not important. There is no NEWLINE token between implicit continuation lines. Implicitly continued lines can also occur within triple-quoted strings; in that case they cannot carry comments.

### <a name="2_1_7"></a> 2.1.7. Blank lines

A logical line that contains only spaces, tabs, formfeeds and possibly a comment, is ignored. During interactive input of statements, handling of a blank line may differ depending on the implementation of the read-eval-print loop.

### <a name="2_1_8"></a> 2.1.8. Indentation

Leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements.

Tabs are replaced (from left to right) by one to eight spaces such that the total number of characters up to and including the replacement is a multiple of eight (this is intended to be the same rule as used by Unix).

Indentation is rejected as inconsistent if a source file mixes tabs and spaces in a way that makes the meaning dependent on the worth of a tab in spaces; a ``TabError`` is raised in that case.

The indentation levels of consecutive lines are used to generate _INDENT_ and _DEDENT_ tokens, using a stack, as follows.

Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again. The numbers pushed on the stack will always be strictly increasing from bottom to top. At the beginning of each logical line, the line’s indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one _INDENT_ token is generated. If it is smaller, it must be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a _DEDENT_ token is generated. At the end of the file, a _DEDENT_ token is generated for each number remaining on the stack that is larger than zero.


Here is an example of a correctly (though confusingly) indented piece of Python code:

```python3
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r
```

The following example shows various **indentation errors**:

```python3
 def perm(l):                       # error: first line indented
for i in range(len(l)):             # error: not indented
    s = l[:i] + l[i+1:]
        p = perm(l[:i] + l[i+1:])   # error: unexpected indent
        for x in p:
                r.append(l[i:i+1] + x)
            return r                # error: inconsistent dedent
```

(Actually, the first three errors are detected by the parser; only the last error is found by the lexical analyzer — the indentation of ``return r`` does not match a level popped off the stack.)

## <a name="2_3"></a> 2.3. Identifiers and keywords

The syntax of identifiers in Python is based on the Unicode standard annex UAX-31, with elaboration and changes.

Within the ASCII range (U+0001..U+007F), the valid characters for identifiers are the same as in Python 2.x: the uppercase and lowercase letters A through Z, the underscore _ and, except for the first character, the digits 0 through 9.

Python 3.0 introduces additional characters from outside the ASCII range.

### <a name="2_3_1"></a> 2.3.1. Keywords

The following identifiers are used as reserved words, or keywords of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here:

```python3
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```

### <a name="2_3_2"></a> 2.3.2. Reserved classes of identifiers

Certain classes of identifiers (besides keywords) have special meanings. These classes are identified by the patterns of leading and trailing underscore characters:

 - ``_*``

 Not imported by ``from module import *``. The special identifier ``_`` is used in the interactive interpreter to store the result of the last evaluation; it is stored in the ``builtins`` module. When not in interactive mode, ``_`` has no special meaning and is not defined.

 - ``__*__``

 System-defined names. These names are defined by the interpreter and its implementation (including the standard library). More will likely be defined in future versions of Python. Any use of ``__*__`` names, in any context, that does not follow explicitly documented use, is subject to breakage without warning.

 - ``__*``

 Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a **mangled form** to help avoid name clashes between “private” attributes of base and derived classes.

## <a name="2_4"></a> 2.4. Literals

Literals are notations for constant values of some built-in types.

### <a name="2_4_4"></a> 2.4.4. Numeric literals

There are three types of numeric literals: integers, floating point numbers, and imaginary numbers. There are no complex literals (complex numbers can be formed by adding a real number and an imaginary number).

Note that **numeric literals do not include a sign; a phrase like -1 is actually an expression composed of the unary operator ‘-‘ and the literal 1.**

### <a name="2_4_5"></a> 2.4.5. Integer literals

Integer literals are described by the following lexical definitions:

```python3
integer      ::=  decinteger | bininteger | octinteger | hexinteger
decinteger   ::=  nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
bininteger   ::=  "0" ("b" | "B") (["_"] bindigit)+
octinteger   ::=  "0" ("o" | "O") (["_"] octdigit)+
hexinteger   ::=  "0" ("x" | "X") (["_"] hexdigit)+
nonzerodigit ::=  "1"..."9"
digit        ::=  "0"..."9"
bindigit     ::=  "0" | "1"
octdigit     ::=  "0"..."7"
hexdigit     ::=  digit | "a"..."f" | "A"..."F"
```

There is **no limit for the length of integer literals** _apart from what can be stored in available memory_.

**Underscores are ignored for determining the numeric value of the literal**. They can be used to group digits for enhanced readability. Note that **leading zeros in a non-zero decimal number are not allowed**. This is for disambiguation with C-style octal literals, which Python used before version 3.0.

Some examples of integer literals:

```python3
7     2147483647                        0o177    0b100110111
3     79228162514264337593543950336     0o377    0xdeadbeef
      100_000_000_000                   0b_1110_0101
```

### <a name="2_4_6"></a> 2.4.6. Floating point literals

Floating point literals are described by the following lexical definitions:

```python3
floatnumber   ::=  pointfloat | exponentfloat
pointfloat    ::=  [digitpart] fraction | digitpart "."
exponentfloat ::=  (digitpart | pointfloat) exponent
digitpart     ::=  digit (["_"] digit)*
fraction      ::=  "." digitpart
exponent      ::=  ("e" | "E") ["+" | "-"] digitpart
```

Note that the integer and exponent parts are **always interpreted using radix 10**. For example, ``077e010`` is legal, and denotes the same number as ``77e10``. The _allowed range of floating point literals is implementation-dependent_. As in integer literals, **underscores are supported for digit grouping**.

Some examples of floating point literals:

```python3
3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93
```

### <a name="2_4_7"></a> 2.4.7. Imaginary literals

Imaginary literals are described by the following _lexical definitions_:

```python3
imagnumber ::=  (floatnumber | digitpart) ("j" | "J")
```

An imaginary literal yields a complex number with a real part of 0.0. Complex numbers are represented as a pair of floating point numbers and have the same restrictions on their range. To create a complex number with a nonzero real part, add a floating point number to it, e.g., (3+4j). Some examples of imaginary literals:

```python3
3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j
```

## <a name="2_5"></a> 2.5. Operators

The following tokens are operators:

```python3
+       -       *       **      /       //      %      @
<<      >>      &       |       ^       ~
<       >       <=      >=      ==      !=
```

## <a name="2_6"></a> 2.6. Delimiters

The following tokens serve as delimiters in the grammar:

```python3
(       )       [       ]       {       }
,       :       .       ;       @       =       ->
+=      -=      *=      /=      //=     %=      @=
&=      |=      ^=      >>=     <<=     **=
```

The period can also occur in floating-point and imaginary literals. A sequence of three periods has a special meaning as an **ellipsis literal**. The second half of the list, the augmented assignment operators, serve lexically as delimiters, but also perform an operation.

The following printing ASCII characters have special meaning as part of other tokens or are otherwise significant to the lexical analyzer:

```python3
'       "       #       \
```

The following printing ASCII characters are not used in Python. Their occurrence outside string literals and comments is an **unconditional error**:

```python3
$       ?       `
```
